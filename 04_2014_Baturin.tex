\documentclass[10pt, a5paper]{article}
\input{preamble.tex}
\switchlang{en}
\begin{document}
\title{Text parsing with python and PLY}
\author{Даниил Батурин, Томск, РФ\footnote{\url{daniil@baturin.org}, \url{http://lvee.org/en/abstracts/122}}}
\maketitle
\begin{abstract}
Language parsing is a common software development problem. Python is widely used in both production software development and rapid prototyping; a number of lexer and parser generators were written for it.
In this talk we discuss using one of them, PLY, which is a pure python implementation of classic lex and YACC tools, for parsing a made-up configuration file grammar.
\end{abstract}
Formal language parsing is a common problem in software development. Standardized formats with already available parsing libraries, such as XML and JSON, have simplified the problem, but did not completely remove it. Python is widely used as a general purpose programming language as well as one for rapid prototyping, so Python programmers face this task as well.

There is a number of parser generators for Python, using different algorithms and APIs. In this talk we discuss PLY that is a pure Python implementation of classic UNIX tools: lex scanner generator, and YACC parser generator. It is maintained by David Beazley and distributed under thee-clause BSD license.

Lex and YACC are there for decades and have been reimplemented not once. This makes PLY easy to learn for UNIX programmers and relatively easy to convert the Python code into C/C++ if needed.

\subsection*{Parsing basics}

There are three typical approaches to make a parser:

\begin{enumerate}
  \item write an ad hoc parser manually,
  \item use a parser generator,
  \item write an advanced parsing algorithm manually.
\end{enumerate}

Ad hoc parsers are suitable for simple grammars, but tend to quickly become hard to maintain and modify. Coding an advanced parsing algorithm like an LL parser is usually redundant and only feasible for very complex grammars or in case of special requirements. For the majority of grammars a parser produced with some parser generator is usually the best option.

Most parser implementations do not work directly with the character stream but use a \emph{token} stream produced by a \emph{scanner}. Using a separate scanner (also known as lexer) to break the stream into tokens simplifies the task as it allows to write grammar rules in terms of token names rather than literal strings, e.g. all arithmetic operators can be referred to as OPSIGN token in a rule for arithmetic expressions. Scanner code is usually generated automatically from a set of regular expressions as well.

The most common algorithm used by parser generators is LALR (1) that reads tokens until a sequence matching the entire grammar rule is found.

\subsection*{Using PLY}

PLY consists of two modules, \verb!ply.lex! and \verb!ply.yacc!. Actions for tokens and grammar rules are defined as functions, while token regular expressions and grammar rules are defined in function docstrings. \linebreak Tokens that need no actions can be defined as variables.

A simple parser for breaking into parts a line consisting of letters and digits groups separated by semicolon will look like:

\begin{verbatim}
import re
import ply.lex as lex
import ply.yacc as yacc

## Lexer part
tokens = ( 'LETTER', 'DIGIT', 'SEMI' )

t_LETTER = r'[a-z]'

def t_DIGIT(t):
    r'[0-9]'
    t.value = int(t.value)
    return t

t_SEMI = r';'
t_ignore = r' '

lexer = lex.lex(debug=1)

## Parser part
start = 'start'

def p_letter_digit_pair(p):
    ''' pair : LETTER DIGIT SEMI '''
    p[0] = (p[1], p[2])

def p_pair_group(p):
    ''' pair_group : pair_group pair
                   | pair
    '''
    print p[0], p[1]
    p[0] = [p[1]] if len(p) == 2 else p[1] + [p[2]]

start = 'pair_group'

parser = yacc.yacc(debug=1)

## Test it
s = "a 0; b 1; c 2;"
print(parser.parse(s))
\end{verbatim}

A more elaborate example discussed in the conference talk can be found at \url{https://github.com/dmbaturin/ply-example}


\begin{thebibliography}{9}
\bibitem{baturin1} PLY website. \url{http://www.dabeaz.com/ply/}
\bibitem{baturin2} Pete Jinks, The Implementation and Power of Programming Languages. \url{http://www.cs.man.ac.uk/~pjj/cs212/ho/ho.html}
\end{thebibliography}

\end{document}
