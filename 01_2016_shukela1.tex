\documentclass[10pt, a5paper]{article}
\input{preamble.tex}
\begin{document}
\title{Введение в ЯП Rust. Ключевые принципы и инженерные идеи\footnote{\url{vi0oss@gmail.com}, \url{http://lvee.org/ru/abstracts/189}}}
\author{Vitaly Shukela, Minsk, Belarus}
\maketitle
\begin{abstract}
Core ideas, features, engineering ideas, pros and cons of Mozilla's Rust programming language.
\end{abstract}
\subsection*{Введение}

Rust "--- язык общего назначения для системного программирования, конкурент C++. Создан в том числе для того, чтобы снизить необходимый уровень квалификации для написания \emph{правильного}, \emph{надёжного} системного кода по сравнению с C++. В C++ легко написать работающий, но полагающийся на неопределённое поведение код. Rust предлагает разобраться со сложностями \emph{безопасного} управления памятью и
многопоточности \emph{до} того, как программа начнёт работать.

Разработчики понимают, что язык сложный и с высоким порогом вхождения. Поэтому значительное внимание уделяется документации, сообщениям об ошибках и непосредственной помощи новичкам через Интернет.

ЯП Rust разрабатывается сообществом под началом Mozilla. Несмотря на то, что у языка нет одного центрального главного автора, ощущение эклектичности и <<design by commitee>> при знакомстве с языком меньше, что можно ожидать (хотя и присутствует).

Ключевые <<X без Y>> принципа ЯП Rust:

\begin{itemize}
  \item безопасность по отношению к памяти без сборки мусора;
  \item поддержка многопоточности без состояний гонки (race condi\-tion);
  \item абстракция без накладных расходов;
  \item стабильность языка без стагнации.
\end{itemize}

Каждый из этих принципов к сожалению имеет и негативную сторону, усложняющую язык.

Rust черпает идеи из многих других ЯП. Можно сказать, что утверждение <<не придумывать своё, сделать правильно уже придуманное>> взято как один из принципов разработки языка. Неполный список языков-<<доноров>>: Ocaml, C++, Haskell, Erlang, Swift, Scheme, C\#.

Rust "--- императивный язык. Функциональное программирование на нём не очень популярно. Есть макросы и плагины к компилятору.

Несмотря на все достоинства ЯП Rust, перед его использованием в реальных проектах следует обратить внимание на недостатки:

\begin{itemize}
  \item Сложность уровня C++. Высокий порог вхождения. <<Была проблема, решил использовать Rust. Теперь у меня   
        \verb!&'a mut! Проблема\verb!<'a, T>!, которую я не могу переместить из заимствованного контекста>>.
Даже после некоторого знакомства с языком, следует ожидать двукратно более медленного программирование по сравнению с, например, C++.
  \item Молодой язык:
  \begin{itemize}
	  \item неполная поддержка IDE;
	  \item не все библиотеки написаны;
	  \item медленная компиляция, нереализованные оптимизации;
	  \item отсутствуют некоторые возможности языка.
  \end{itemize}
  \item ABI нестабилизировано и несовместимо между версиями языка (как в C++, но не как в C).
\end{itemize}

\subsection*{Управление памятью в Rust}

В Rust есть три режима доступа к объекту:

\begin{itemize}
  \item Владение: \verb@x@
  \item Доступ на запить: \verb@&mut x@
  \item Доступ на чтение: \verb@&x@
\end{itemize}

Эта тройственность бывает заметна в разных местах языка и стандартной библиотеки.

У каждого режима есть свои особенности:

\begin{itemize}
  \item Владелец отвечает за освобождение памяти и выход деструктора. Может <<раздавать>> ссылки \verb@\&@ и \verb@\&mut@.
  \item Доступ на запить означает, что объект можно изменять, а не только читать. Но после сеанса редактирования объект должен остаться на месте, и ссылку (заимствование) нужно <<вернуть на место>> владельцу.
  \item Доступ только на чтение. Это единственный режим с разделяемым доступом на уровне языка. В двух предыдущих режимах доступ монопольный.
\end{itemize}

Естественно, есть ещё специальный <<небезопасный>> режим с настоящими указателями в стиле C, без <<приставленного к ним маленького милиционера, который следит за доступом>>. В этом спецрежиме (<<Unsafe Rust>>) реализовывается связь с библиотеками на других ЯП (в частности, на С) и структуры данных. Это позволяет реализовывать умные указатели со своими режимами доступа в библиотеках.

Вне этого спецрежима действуют гарантии языка по надёжности.

Следует обратить внимание на список ситуаций, которые \emph{не} входят в эти гарантии:

\begin{itemize}
  \item утечки памяти, невызовы деструкторов, нарушение RAII, например, из-за циклов в указателях с подсчётом ссылок;
  \item взаимоблокировки нитей;
  \item целочисленные переполнения (когда контроль переполнений отключен);
  \item переполнение стека (аварийное завершение программы, но без неопределённого поведения);
  \item вмешательсово в работу программы со стороны (отладчиком и т.д.);
  \item игнорирование некоторых труднообрабатываемых с RAII ошибок (системных вызов close).
\end{itemize}

Пример срабатывания контроля заимствований:

\begin{verbatim}
fn eat_box(boxed_int: Box<i32>) {
   println!("Объект, содержаций внутри {}\
             , освобождается из памяти", boxed_int);
}
fn peep_inside_box(borrowed_int: &i32) {
   println!("Заглянули в объект, внутри {}", borrowed_int);
}
fn main() {
   let boxed_int = Box::new(5);
   peep_inside_box(&boxed_int);
   peep_inside_box(&boxed_int);
   {   let _ref_to_int: &i32 = &boxed_int;
       eat_box(boxed_int); /* не компилируется */ 
   } // reference goes out of scope;
   eat_box(boxed_int);
}\end{verbatim}
У каждого заимствования (ссылки на объект) есть время жизни. Эти времена жизни,
о которых иногда идёт речь и при описании других ЯП, выражены в Rust явно и входят
в синтаксис языка (lifetimes). На этапе компиляции они проверяются. Функции, 
могущие оперировать со ссылками с разными временами жизни считаются обобщёнными
(generic) и имеют специальный дополнительный параметр.

Пример:

\verb@fn choose<'a,'b>(j:&'a i32, k:&'b i32) -> &'a i32 { j }@



Расшифровка примера приведена в таблице \ref{tab1}.

\begin{table}
\caption{~}\label{tab1}
  \centering
  \begin{tabular}{|p{1.5cm}|l|}
  \hline
     \verb@fn@       &  Определяем функцию                                     \\
     \verb@choose@   &  <<choose>>                                               \\
     \verb@<@        &    с двумя generic-памаметрами:                         \\
     \verb@'a,@      &      время жизни \verb!'a! и                                   \\
     \verb@'b>@      &      время жизни \verb!'b!;                                    \\
     \verb@(@        &    с двумя аргументами:                                 \\
     \verb@j:@       &      \verb!j! "---                                                \\
     \verb@&@        &        ссылка,                                          \\
     \verb@'a@       &        имеющая время жизни \verb!'a!,                          \\
     (пустота)  &        только для чтения                                \\
     \verb@i32,@     &        на 32-разнядное число со знаком;                 \\
     \verb@k:@       &      \verb!k! "---                                                \\
     \verb@&'b i32@  &        ссылка только чтение на i32 с временем жизни \verb!'b!, \\
     \verb@->@       &    возвращающая                                         \\
     \verb@&'a i32@  &      ссылку только чтение на i32 с временем жизни \verb!a!,    \\
     \verb@{ j }@    &    а именно, свой первый аргумент.                      \\
     \hline
  \end{tabular}
\end{table}
Прослеживая lifetime, компилятор Rust может рассуждать, действительно ли соблюдаются принципы работы с памятью:

\begin{itemize}
  \item нет доступа на запить из нескольких мест к одному и тому же;
  \item нет чтения неинициализированной памяти;
  \item нет доступа к объекту, если он уже освобождён.
\end{itemize}

Это всё проверяется из типов данных и сигнатур функций. В частности,
в приведённом выше примере невозможно было бы определить, какое время жизни у возвращаемой функцией choose ссылки, без <<подглядывания>> в реализацию <<\{ j \}>> (которая может быть в общем случае далеко от объявления).

Когда речь идёт о безопасности памяти и ссылках, Rust предпочитает быть скорее сложным, чем нестрогим. Можно частично избежать сложностей работы со ссылками в Rust путём использования доступных в стандартной библиотеке умных указателей \verb!Rc!, \verb!Arc! и \verb!Cow!.

Так же как типы наследуются друг от друга в других ЯП, lifetime <<наследуются>> в Rust.

\begin{verbatim}
   'a : 'b\end{verbatim}
Это означает, что \verb!'a! шире \verb!'b! (начинается не позднее начала, заканчивается не ранее конца \verb!'b!). Значит, где требуется ссылка \verb!&'b!,
можно использовать и \verb!&'a! (но не наоборот). Аналогично, из ссылки \verb!&'a! можно сделать ссылку \verb!&'b! (но не наоборот).

\begin{verbatim}
   зона действия 'a {
        ...
        зона действия 'b {
            ...
        }
        ...
    }\end{verbatim}
\subsection*{Интерфейсы (Traits), типы и generics.}

Два пользовательских составных объекта в Rust "--- это структуры и перечисления. Они приблизительно соответствуют конструкциям С struct и union (с тегом).

Также можно задавать набор сигнатур функций (интерфейс, trait) который можно <<привязывать>> к типу данных.

Для trait'ов есть наследование, для обычных типов данных его нет.

И trait'ы, и типы данных могут быть generic, то есть определять семейство интерфейсов или типов в зависимости от набора типов-пареметров.

Реализации некоторых интерфейсов может предоставить сам компилятор:

\begin{verbatim}
   #[derive(Debug, Eq, PartialEq, Ord, PartialOrd)]
    struct SomeEntry {
        pub q : String,
        w : i32,
    };
    
    #[derive(Copy)]
    enum Q {
        Variant1,
        Variant2(usize),
    }\end{verbatim}
В отличие от C++, реализации generic-функций проверяются на правильность до инстанцирования конкретными типами.

Пример использования интерфейса:

\begin{verbatim}
   trait Qqq {
        fn a(&self) -> i32;
    }
    
    struct Www {
        g: isize;
    }
    
    impl Qqq for Www {
        fn a(&self) -> i32 { self.g }
    }\end{verbatim}
Помимо generic-параметров <<на входе>>, интерфейсы могут также давать типы <<на выход>>

\begin{verbatim}
   trait MyTrait<T> {
        type Output;
        fn qqq(&self) -> Self::Output;
    }
    
    struct Lol;
    struct LolOut;
    impl MyTrait<u8> for Lol {
        type Output = LolOut;
        fn qqq(&self) -> LolOut { LolOut }
    }\end{verbatim}
Библиотеки могут оставлять интерфейсы для реализации пользователям. При этом есть специальное правило: нельзя реализовывать (\verb!impl!) чужой (из другого компонента) интерфейс для чужого типа. При помощи этого правила обеспечивается сочетаемость компонентов "--- каждая реализация <<привязана>> к компоненту типом и/или интерфейсом.

\subsection*{Прочие возможности ЯП Rust}

Ниже приведен краткий перечень других возможностей языка с примерами их использования.

Rust поддерживает макросы.

\begin{verbatim}
   macro_rules! o_O {
        (  $(
                $x:expr; [ $( $y:expr ),* ]
            );*   ) => {
            &[ $($( $x + $y ),*),* ]
        }
    }
    
    fn main() {
        let a: &[i32] = 
            o_O!(10; [1, 2, 3];
                 20; [4, 5, 6]);
    
        assert_eq!(a, [11, 12, 13, 24, 25, 26]); 
    }\end{verbatim}
В Rust широко используются итераторы:

\begin{verbatim}
let a = [1, 4, 2, 3, 8, 9, 6];
let sum: i32 = a.iter()
                 .map(|x| *x)
                 .inspect(|&x| println!("filtering {}", x))
                 .filter(|&x| x % 2 == 0)
                 .inspect(|&x| println!("{} seen", x))
                 .fold(0, |sum, i| sum + i);
println!("{}", sum);\end{verbatim}
Тесты можно включать прямо в документацию к библиотеке:

\begin{verbatim}
   /// Clears the map, removing all values.
    ///
    /// # Examples
    ///
    /// <<`
    /// use std::collections::BTreeMap;
    ///
    /// let mut a = BTreeMap::new();
    /// a.insert(1, "a");
    /// a.clear();
    /// assert!(a.is_empty());
    /// <<`\end{verbatim}
Помимо дженериков можно использовать также и type erasure.

Также предусмотрены две системы обработки ошибок: \verb!panic/! \verb!unwind! и \verb!Result!.

\subsection*{Заключение}

Изучение ЯП Rust "--- хорошая идея для системных программистов независимо от использования или неиспользования языка в реальных проектах. Язык сравнивают с аппаратом Илизарова для небрежных программистов на C/C++ "--- после Rust <<руки выпрямляются>> и код получается более качественным в т.ч. за его пределами.

%\subsection*{Источники.}
\begin{thebibliography}{9}
\bibitem{shukela1-1}Публичный протокол чата Rust. \url{https://botbot.me/mozilla/rust/}
\bibitem{shukela1-2}Тред <<цитаты о Rust>>. \url{https://users.rust-lang.org/t/twir-quote-of-the-week/328/272}\bibitem{shukela1-3}Презентация доклада. \url{https://vi-server.org/pub/rust.pdf}
\end{thebibliography}
\end{document}
