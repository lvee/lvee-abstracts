\documentclass[10pt, a5paper]{article}
\input{preamble.tex}

\begin{document}

\title{Ускорение загрузки Linux на ARM"=процессоре}%\footnote{Текст данных и последующих тезисов, кроме специально оговоренных случаев, доступен под лицензией Creative Commons Attribution-ShareAlike 3.0}

\author{Андрей Пушкин\footnote{Минск, Беларусь; \url{andrew.pushkin@gmail.com}}}
\maketitle

\begin{abstract}
Speeding up Linux loading on ARM SOC is considered. Steps to speed up loading Linux on ARM board: review boot scheme (initramfs, no initramfs, filesystems, user space soft) and check loading time of all booting parts; customize pre"=bootloader (on ARM TI AM3517 CPU is X"=Load), turn off any console output, customize memory timings; customize bootloader (U"=Boot), turn off any unused peripheral, rewrite some slow places; customize Linux kernel, turn off all unused options, move everything else to modules that come later; customize user space soft, loading GUI prior to other soft.
\end{abstract}

Перед автором была поставлена задача максимально ускорить процесс загрузки устройства с embedded Linux. Был предложен следующий план работы:

\begin{enumerate}
  \item Изучение работы системы и разбиениее ее на отдельные части для последующей оптимизации.
  \item Измерение времени загрузки каждого компонента системы. Для измерения использовались вывод отладочных сообщений в UART с засеканием времени их появления на Host"=PC.
  \item Оптимизация времени загрузки каждого компонента.
  \item Измерение времени работы оптимизированной системы, фиксация результатов.
Изначальное время загрузки устройства составляло 48 секунд. Исходным требованием было сократить время загрузки минимум до 5 секунд.
\end{enumerate}

Устройство имело следующую конфигурацию:

\begin{enumerate}
  \item Процессор Texas Instruments AM3505 (600 Mhz Cortex"=A8)
  \item 128 MB LPDDR2 RAM
  \item 256 MB NAND
  \item Touchscreen $320\times240$
  \item USB Host, USB Device, MMC, Bluetooth
\end{enumerate}

В начале работы система была разбита на модули и было измерено время загрузки каждого из них. Данные оказались следующими:

\begin{enumerate}
  \item X"=Load	- 200 миллисекунд
  \item U"=Boot	- 15050 миллисекунд
  \item Linux	- 9200 миллисекунд
  \item User Space Soft "--- 22000 миллисекунд
\end{enumerate}

\textbf{X"=Load "--- предварительный загрузчик}

В момент разработки проекта был актуален, сейчас x"=load интегрирован в U"=Boot и называется SPL.
Из X"=Load было вырезано всё, что связано с отладочным UART. Это дало выигрыш в 150 миллисекунд.

\textbf{U"=Boot "--- загрузчик ядра операционной системы}

В U"=Boot были сделаны следующие оптимизации:

\begin{enumerate}
  \item Изменение алгоритма загрузки
  -- Отказ от Initramfs. Суть Initramfs заключается что что Linux + rootfs читаются из NAND одним образом.
  -- Возврат к классической схеме загрузки, когда u"=boot читает только маленький образ ядра операционной системы без rootfs"=программ.
  Это дало выигрыш в 7300 миллисекунд.
  \item Отказ от подсчёта CRC в образе ядра Linux (в файле uImage). По"=умолчанию U"=boot считает контрольную сумму, и если она не совпадает с тем, что записано в uImage "--- не загружает его. Отказ от этой схемы привел к тому, что u"=boot всегда загружает ядро Linux, и дал выигрыш в 1200 миллисекунд.
  \item Уменьшение размера ядра Linux путём вынесения всего, что можно, в модули, которые загружаются позже. Это позволило уменьшить ядро Linux и значительно ускорить его чтение. Выигрыш составил 600 миллисекунд.
  \item Включение аппаратного NAND ECC дало выигрыш в 200 миллисекунд.
  \item Удаление инициализации из U"=Boot неиспользуемых частей: I2C, SPI, USB Host, USB device, MMC, драйверов ext2"=3, VFAT дало выигрыш в 700 миллисекунд.
  \item Встраивание картинки «Loading» (чтобы показать, что прибор загружается) в образ U"=boot взамен считывания ее картинки с NAND"=памяти дало выигрыш в 100 миллисекунд.
  \item Переписывание memmove под Cortex"=A8. Это дало выигрыш в 2250 миллисекунд
Всё в сумме привело к времени загрузки в 3000 миллисекунд вместо 15050.
\end{enumerate}

\textbf{Оптимизация Linux}

Были сделаны следующие оптимизации:

\begin{enumerate}
  \item Удаление из конфига ядра инициализации всего «лишнего» (ненужные драйвера, отладочные опции и так далее). Это дало выигрыш в 100 миллисекунд
  \item Вынесение всего, что возможно, в модули, которые загружаются позже. Это дало выигрыш в 8150 миллисекунд.
Всё в сумме дало время загрузки в 1050 миллисекунд вместо 9200.
\end{enumerate}

\textbf{Оптимизация User Space}

Схема загрузки до оптимизации включала следующие этапы:

\begin{enumerate}
  \item Ядро Linux
  \item Init скрипты
  \item Монтирование раздела с настройками
  \item Монтирование раздела с данными
  \item Запуск Qt4 GUI программы.
\end{enumerate}

В ходе оптимизации был убран раздел с настройками, которые стали хранится на основном разделе. Графическая программа на Qt4 начала запускаться как можно раньше чтобы показать меню программы как можно раньше, а остальные части загружать позднее.

В результате получилась следующая схема загрузки:

\begin{enumerate}
  \item Ядро Linux
  \item Qt4 GUI (не блокирующий запуск)
  \item Init скрипты
  \item Загрузка модулей ядра Linux
  \item Монтирование раздела с данными
  \item запуск Qt4 GUI программы
\end{enumerate}

Также в ходе оптимизации было сделано следующее:

\begin{enumerate}
  \item Перед запуском графической Qt4"=программы ставится её скриношот. Сама программа запускается 1500 миллисекунд.
  \item Файловая система заменена с JFFS2 на UBI, что дало выигрыш 5--10 секунд на монтировании
  \item Графическая Qt4"=программа переписана таким образом, чтобы сначала загружались те её части, которые отвечают за главное меню, и лишь потом "--- всё остальное
\end{enumerate}

В ходе работы были получены результаты:

\begin{enumerate}
  \item Показ меню прибора за 5 секунд
  \item Показ графического ПО за 6.5 секунд
  \item Полная загрузка прибора за 27 секунд
\end{enumerate}


\end{document}




