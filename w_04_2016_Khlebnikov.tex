\documentclass[10pt, a5paper]{article}
\input{preamble.tex}
\switchlang{en}
\begin{document}
\title{Comparative Review of FLOSS Testing Frameworks for Embedded C++\footnote{\url{alexei.khlebnikov@gmail.com}, \url{http://lvee.org/ru/abstracts/171}}}
\author{Алексей Хлебников, Oslo, norway}
\maketitle
\begin{abstract}
Every software development group tests its products, yet delivered software always has defects. Test engineers strive to catch them before the product is released but they always creep in and they often reappear, even with the best manual testing processes. Automated tests is the best way to increase \linebreak the effectiveness, efficiency and coverage of your software testing. This comparative review evaluates several C++ testing \linebreak frameworks with focus on usage in modern embedded systems, like Android and iOS.
\end{abstract}
\subsection*{Requirements}

It turns out that most automated testing frameworks for C++ were designed for Desktop, as opposed to Embedded devices. They usually report test results to standard output, many frameworks even supply main() function. On Embedded platforms we usually don't have stdout and applications can not use main() function, generated by the frameworks. We need to capture testing report into memory and then either output it to the log, or to some nice window on the device.

Thus, our requirements for testing frameworks are as follows:

\begin{itemize}
  \item Cross-platform, i.e. support for testing on Android, iOS, Linux, MacOS X, Windows.
  \item Support for custom test runner, because we don't have main() on Android or iOS.
  \item Support for custom outputter, because we don't have stdout on Android and iOS.
  \item Support for fixtures, i.e. setup/teardown.
  \item Support for testsuites, i.e. test grouping.
\end{itemize}

Non-mandatory, but desired features:

\begin{itemize}
  \item Easy and pleasant to use: Sensible and logical design, good \linebreak documentation, sensible syntax, terminology and keywords.
  \item The framework should be supported and mature.
  \item The less boilerplating "--- the better. For example, automatic test registration.
  \item Support for running test selectively, preferably by regex match on test names.
  \item Support for listing available tests.
\end{itemize}

\subsection*{Testing framework list}

The following testing frameworks were evaluated:

\begin{itemize}
  \item Bandit
  \item Boost.Test
  \item CATCH
  \item CppUnit
  \item CxxTest
  \item Google Test
  \item Igloo
  \item Lest
  \item TUT
  \item UnitTest++
\end{itemize}

\subsection*{More about each framework}

\subsubsection*{CppUnit}

C++'s classics of the classics. The first xUnit-like testing framework for C++. Powerful and feature-rich. Has good documentation. \linebreak Unfortunately, test registration is not automatic and developer will need to retype test class and function names several times. xUnit-like frameworks in other languages, like Java and Ruby, do not require such manual test registration, because they, unlike C++, have reflection mechanisms, which are used for automatic test discovery.

Code example:
\begin{verbatim}
class MyTestSuite : public CppUnit::TestFixture
{
public:
    void setUp()
    {
        m_num = 2;
    }

    void tearDown()
    {
        m_num = 0;
    }

    void testOneThing()
    {
        CPPUNIT_ASSERT(m_num == 2);
    }

    void testAnotherThing()
    {
        CPPUNIT_ASSERT_EQUAL(m_num * m_num, 4);
    }
    ...
};

...

auto* suite = new CppUnit::TestSuite("MyTestSuite");

suite->addTest(
    new CppUnit::TestCaller <MyTestSuite> (
        "testOneThing",
        &MyTestSuite::testOneThing
    )
);

suite->addTest(
    new CppUnit::TestCaller <MyTestSuite> (
        "testAnotherThing",
        &MyTestSuite::testAnotherThing
    )
);

CppUnit::TextUi::TestRunner runner;

runner.addTest(suite);

\end{verbatim}

Supports:

\begin{itemize}
  \item Custom runner.
  \item Custom outputter by subclassing class TextOutputter and \linebreak overriding 1 function.
  \item Fixtures and testsuites.
  \item Listing available tests.
  \item Selective running of one particular test.
  \item Unlike most other frameworks, defining and registering test both using C++-only code and using macros.
\end{itemize}

Downsides:

\begin{itemize}
  \item Test autoregistration is almost non-existing. There are helper macros, but they do not help enough.
  \item This framework requires much boilerplating. People on the Internet complain about it a lot.
  \item The framework is supported, but not very actively. Currently it is supported by LibreOffice team. On the other hand, the framework already has so many features, that it does not need much further development. Sure, there is a room for improvement with boilerplating, but such work suggests so much refactoring that it is easier to just take another testing framework.
\end{itemize}

Verdict:

CppUnit requires too much boilerplating. It was probably OK 15 years ago, when C++ developers did not have much choice, but for 2016 it is too bad.

\subsubsection*{Google Test}

Powerful framework with lots of features and complicated syntax. Has good documentation. Unfortunately, it is hard to redirect output. It is one of the first testing frameworks, featuring automatic test \linebreak registration. C++ still does not have reflection, but Google Test \linebreak overcomes this obstacle by using macros, that both define and register tests.

Supports:

\begin{itemize}
  \item Custom runner.
  \item Fixtures and testsuites.
  \item Test autoregistration.
  \item Listing available tests.
  \item Running subset of tests, including and excluding them by path-like wildcards.
\end{itemize}

Downsides:

\begin{itemize}
  \item Custom outputter is not supported. The framework uses C file descriptors for output. The best that can be done is redirecting output to the file.
\end{itemize}

Verdict:

Google Test is not good enough for us, because custom outputter is not supported.

\subsubsection*{Boost.Test}

Powerful framework with lots of features and complicated syntax. Has good documentation. Did not support autoregistration before, but supports now. Can be compiled as static or dynamic library or used as header-only library. People on the Internet report that in case of header-only library compilation takes quite long time. Typical for a Boost library.

Code example:

\begin{verbatim}
struct MyFixtureStructure
{
    MyFixtureStructure()  { m_num = 2; }
    ~MyFixtureStructure() { m_num = 0; }
    ...
};

BOOST_FIXTURE_TEST_SUITE( MyTestSuite, MyFixtureStructure )

    BOOST_AUTO_TEST_CASE( test_one_thing )
    {
        BOOST_REQUIRE(m_num == 2);
    }

    BOOST_AUTO_TEST_CASE( test_another_thing )
    {
        BOOST_CHECK_EQUAL(m_num * m_num, 4);
    }

BOOST_AUTO_TEST_SUITE_END()

\end{verbatim}
Supports:

\begin{itemize}
  \item Custom runner.
  \item Custom outputter by subclassing std::ostream.
  \item Fixtures and testsuites.
  \item Test autoregistration.
  \item Listing available tests.
  \item Running subset of tests, selecting by path-like wildcards and tags.
\end{itemize}

Verdict:

Good candidate, supports all our requirements. Can we find better?

\subsubsection*{CxxTest}

Lightweight framework with good design and syntax. Implements automatic testcase registration by running a Python script, instead of clumsy macros, used by other testing frameworks. Each testsuite is a class with (optional) setUp/tearDown functions, each test is a function starting with <<test>>. As a result, a testsuite looks like a nice C++ class. The framework has good, even though not very long, documentation and easily readable source code otherwise.

Code example:

\begin{verbatim}
class MyTestSuite : public CxxTest::TestSuite
{
public:
    void setUp()
    {
        m_num = 2;
    }

    void tearDown()
    {
        m_num = 0;
    }

    void testOneThing()
    {
        TS_ASSERT(m_num == 2);
    }

    void testAnotherThing()
    {
        TS_ASSERT_EQUALS(m_num * m_num, 4);
    }
    ...
};
\end{verbatim}
Supports:

\begin{itemize}
  \item Custom runner.
  \item Custom outputter by subclassing class OutputStream and \linebreak overriding 3 functions.
  \item Fixtures and testsuites.
  \item Test autoregistration without macros.
  \item Listing available tests.
  \item Selective running of one particular test or testsuite.
\end{itemize}

Downsides:

\begin{itemize}
  \item Introduces dependency on Python for a C++ project.
  \item The Python script, used for testing code processing, has simplified C++ parser. Thus testing code must be kept parser-friendly. Fortunately, it is not hard.
\end{itemize}

Verdict:

Good candidate, supports all our requirements. Avoids macros, code looks cleaner. Can we still find better?

\subsubsection*{CATCH}

New-generation testing framework, supporting both usual xUnit-style tests and TDD/BDD-style tests with SECTIONS and \linebreak SCENARIOS. SECTIONS is a killer feature, allowing to save a lot of code on fixtures. SCENARIOS is development of the SECTIONS idea, more descriptive, but requires more typing.

Code example:

\begin{verbatim}
TEST_CASE( "My test suite name", "[my_tag]" )
{
    num = 2;

    SECTION( "increment" )
    {
        num++;
        REQUIRE(num == 3);
    }

    SECTION( "decrement" )
    {
        num--;

        SECTION( "increment after decrement" )
        {
            num++;
            REQUIRE(num == 2);
        }

        SECTION( "2 decrements" )
        {
            num--;
            REQUIRE(num == 0);
        }
    }
}
\end{verbatim}
Using SECTIONS, it is possible to combine fixture code with testing code. The above code is equivalent to 3 tests in xUnit model:

\begin{verbatim}
TEST_CASE( "increment" )
{
    num = 2;
    num++;
    REQUIRE(num == 3);
}

TEST_CASE( "increment after decrement" )
{
    num = 2;
    num--;
    num++;
    REQUIRE(num == 2);
}

TEST_CASE( "2 decrements" )
{
    num = 2;
    num--;
    num--;
    REQUIRE(num == 0);
}
\end{verbatim}
As we can see, SECTIONS provide a way to compactly describe several tests in a tree-like manner.

Supports:

\begin{itemize}
  \item Custom runner.
  \item Custom outputter by subclassing std::ostream.
  \item Fixtures and testsuites.
  \item SECTIONS and SCENARIOS!
  \item Test autoregistration.
  \item Listing available tests.
  \item Running subset of tests, selecting by path-like wildcards and tags.
\end{itemize}

Verdict:

Surprisingly good young contender. Supports all our requirements and in addition has SECTIONS killer feature. We have a winner!

Evaluation of other testing frameworks follows for completeness of the review.

\subsubsection*{Lest}

Aims to be C++11-fied version of CATCH. Seems to be less powerful than CATCH so far, and less mature. The first commit on GitHub for lest was in June 2013, vs November 2010 for CATCH. According to lest homepage, lest takes much more time to compile, probably because of excessive use of C++11 features.

\subsubsection*{Igloo}

BDD-style framework with unclear syntax and bad documentation. Seems to be inactively supported: the last commit on GitHub is from July 2015, but the last release was in 2013. Seems like the author devotes his attention to his another testing framework, Igloo.

\subsubsection*{Bandit}

Another BDD-style framework with unclear syntax and bad \linebreak documentation. C++11-fied version of Igloo framework from the same author. C++11 syntax was supposed to make the syntax better, but, I believe, the opposite happened: Bandit syntax is even worse than Igloo syntax, despite that the author calls it <<Human friendly unit testing for C++11>>.

\subsubsection*{TUT}

Old framework with awful syntax, relying on C++ templates instead of C++ macros. Unsupported: the last release was in 2013, commit rate is approximately 2 commits per year.

\subsubsection*{UnitTest++}

Minimalistic framework with <<usual>> syntax with C++ macros TEST/SUITE/CHECK/etc. Documentation is quite brief. \linebreak The framework seems to be supported, though not much development is being done, probably because the intention is to keep the framework minimalistic. The last release and the last commit was in November 2015.

Supports:

\begin{itemize}
  \item Custom runner.
  \item Custom outputter by subclassing class TestReporter and \linebreak overriding 4 functions.
  \item Fixtures and testsuites.
  \item Test autoregistration.
\end{itemize}

Downsides:

\begin{itemize}
  \item No support for listing available tests.
  \item No support for selective test running.
\end{itemize}

Verdict:

Good choice, if you want very light-weight and minimalistic \linebreak framework. If you want more features "--- choose something else.

\subsection*{Conclusion}

Considering upsides and downsides of different testing frameworks, I am giving top 3 places to these frameworks that satisfy all our \linebreak requirements:

\begin{enumerate}
  \item CATCH, for supporting SECTIONS.
  \item CxxTest, for avoiding clumsy macros, easy implementation of custom outputter and generally good design.
  \item Boost.Test, for being feature-rich, mature and quality product.
\end{enumerate}

\end{document}
