\documentclass[10pt, a5paper]{article}
\input{preamble.tex}
\begin{document}
\def\v!#1!{\texttt{#1}}
\title{Удобства и особенности OpenBSD Ports}
\author{Вадим Жуков, Москва, РФ\footnote{\url{zhuk@openbsd.org}, \url{http://lvee.org/en/abstracts/103}}}
\maketitle
\begin{abstract}
OpenBSD acquired Ports framework from FreeBSD many years ago, and since then those frameworks diversed very much. Current OpenBSD Ports infrastructure makes it possible to have many up-to-date ports, including ‘heavy’ ones like GNOME, LibreOffice and KDE, by relatively few number active maintainers. This talk is about features of current OpenBSD ports system: bulk package builds, package signing and updating, manual library versions handling, modules framework and other stuff.
\end{abstract}
Как в любой нормальной современной ОС общего назначения, в OpenBSD есть механизм для установки стороннего ПО. В данном случае "--- OpenBSD Ports, происходящие, как многие знают, от FreeBSD Ports. Однако, сохранив ряд внешних признаков прародителя, OpenBSD Ports кардинально отличаются от FreeBSD Ports внутри. Проще всего это показать, перечислив то, что сохранилось:

\begin{enumerate}
  \item Использование Makefile для описания порта.
  \item Названия основных операций и ряд переменных, используемых в этом Makefile.
\end{enumerate}

Во всём остальном OpenBSD Ports заметно ушли вперёд "--- впрочем, разработчики FreeBSD раскачались и стали догонять, что видно на примере свежевышедшей FreeBSD 10.

Ключевые особенности OpenBSD Ports:

\begin{enumerate}
  \item Сборка пакета "--- обязательный этап. Пакет сначала собирается, и только потом ПО устанавливается из него в систему.
  \item Контроль сборки посредством \v!systrace!(1), \v!sudo!(8), fake-\linebreak{}фреймворка и \v!pkg\_create!(1). Файлы для пакета помещаются в отдельный каталог, а не прямо на рабочую систему. В ходе «фальшивой установки» отлавливается запись за пределы рабочего каталога (кроме \v!/tmp! и \v!/var/tmp!).
  \item Поддержание целостности дерева портов посредством непрерывной сборки пакетов с использованием \v!dpb(1)!.
  \item Четыре вида зависимостей: \v!BUILD\_DEPENDS!, \v!LIB\_DE\-PENDS!, \v!RUN\_DEPENDS!, \v!TEST\_DEPENDS!.
  \item Опции и субпакеты, см. «FLAVORS AND MULTI\_PACKAGES» в \v!bsd.port.mk!(5).
  \item Модули, см. \v!port-modules!(7).
  \item Реально работающий механизм обновления пакетов, с учётом переименований, требований к конкретным версиям, наличия конфликтов и т.\,д.
  \item Ручной контроль версий «публичных» разделяемых библиотек.
\end{enumerate}

Благодаря имеющимся средствам автоматизации большинства рутинных операций и жёстком контролю в виде \v!dpb!(1), на поддержание высокого качества пакетов уходит сравнительно небольшое количество сил. Как результат, в OpenBSD при сравнительно небольшом количестве мейнтейнеров поддерживается большая часть современного софта. Текущие примеры:

\begin{itemize}
  \item порты GNOME и XDG-стек поддерживаются всего двумя \linebreak людьми
  \item порты LibreOffice и Chromium "--- одним и тем же человеком
  \item KDE 3 и 4 "--- одним и тем же человеком
  \item все порты Mozilla-приложений "--- одним и тем же человеком
\end{itemize}

О субпакетах и опциях:

OpenBSD Ports, как и другие аналогичные системы, позволяет задавать для пакетов опции сборки. Основные отличия OpenBSD в этой области следующие:

\begin{itemize}
  \item Количество опций OpenBSD старается поддерживать на минимальном уровне. Это позволяет при разумных усилиях тестировать все или почти все возможные варианты пакетов.
  \item Используемые при сборке опции записываются в имя пакета через дефис, после номера версии. Например:\\
\verb!kdelibs-4.11.5-debug!\\
\verb!vim-7.4.45p2-huge-gtk2-python!
\end{itemize}


Благодаря этому в репозитории пакетов вместе могут одновременно находиться разные варианты пакетов, и не возникает вопросов вроде «какие опции были использованы для пакета?».

Изначально в FreeBSD Ports было чёткое соответствие: одна сборка "--- один пакет. Когда требовалось собирать несколько разных пакетов на базе одного порта (например: \v!postgresql"=client! и \v!postgresql"=server!), то один порт включал себя директивой \v!.in\-clu\-de! другой, незначительно модифицировал переменные и предоставлял альтернативный plist. Таким образом, сборка этих двух пакетов должна была бы происходить дважды, либо требовала довольно «грязных» хаков.

В OpenBSD Ports имеется возможность создавать из одного порта несколько пакетов. Строго говоря, корректнее было бы говорить о субпортах, а не субпакетах, так как создаваемые пакеты являются изначально независимыми и могут иметь любые (допустимые) имена. Однако менять название переменной теперь никто не собирается.

Названия самих субпакетов начинаются с дефиса. Это делается для возможности отличать субпакеты от опций в \v!FULL\-PKG\-PATH! "--- своеобразном «пути», используемом для пакета с портом, из которого он собирается. \v!FULL\-PKG\-PATH! "--- своего рода идентификатор (суб-)пакета и играет большую роль на всех этапах работы с пакетами.

Наравне с \v!FULLPKGPATH! имеется \v!FULL\-PKG\-NAME!. Если \v!PKG\-NAME! содержит собственно название пакета и его версию, то в \v!FULL\-PKG\-NAME! к этому добавляются номера ревизии порта (\v!RE\-VI\-SI\-ON!) и эпохи порта (\v!EPOCH!), а также используемые опции. Именно \v!FULL\-PKG\-NAME! и становится именем конечного файла, содержащего собранный пакет (не считая расширения).

Для портов также можно задавать псевдоопции (\v!PSEUDO\_FLA\-VORS!). Они используются в тех случаях, когда необходимо управлять сборкой порта без влияния на содержимое создаваемых пакетов. Обычно это ситуации, когда нужно избежать лишних зависимостей при сборке, когда какие-то субпакеты являются лишними, или, например, зависимости нужны только для прогона тестов. Псевдоопции не записываются в имени пакета.

Так как отдельные субпакеты могут выпадать и по другим причинам (например, непригодность для какой-то аппаратной архитектуры) посредством переменных вида \v!BROKEN"=subpkg! и \v!IGNORE"=subpkg!, для конечного определения параметров сборки имеется \linebreak вспомогательный механизм \v!bsd.port.arch.mk!(5). Хотя внешне он кажется аналогом \v!bsd.port.pre.mk! из FreeBSD, назначение у них всё же разное: \v!bsd.port.arch.mk! используется только для двух вещей:
\begin{enumerate}
  \item Определение аппаратной архитектуры, под которую собирается пакет.
  \item Вычисление переменной \v!BUILD\_PA\-CKA\-GES!, содержащей список подлежащих сборке пакетов. После включения \linebreak \v!<bsd.port.arch.mk>! порт может использовать проверки вида \linebreak \texttt{.if \$\{BUILD\_PA\-CKA\-GES:M-subpkg\}} для определения, нужно ли включать сборку определённого субпакета.
\end{enumerate}

Результаты данных проверок обычно используются для установки специфичных параметров конфигурации и наборов зависимостей.

О модулях:

Модули "--- Makefile, подключаемые OpenBSD Ports по просьбе порта. Модули могут как модифицировать переменные, так и устанавливать или добавлять обработчики стандартных операций. Для подключения модуля достаточно добавить его имя в переменную \v!MODULES!. Примеры модулей:

\begin{enumerate}
  \item Один из самых простых модулей "--- \v!converters/libiconv!. Всё, что он делает "--- добавляет ряд зависимостей для порта и дополняет \v!WANTLIB! (список используемых портом разделяемых библиотек).
  \item Более сложный модуль "--- \v!devel/cmake!. Он используется портами, которые, как не трудно догадаться, собираются при помощи CMake. Данный модуль устанавливает ряд переменных, используемых CMake при конфигурировании и сборке, в том числе для: выбора движка сборки (поддерживаются make и Ninja), перекрытия версий разделяемых библиотек, настройки вывода прогресса сборки и т.\,д.
  \item Модуль \v!lang/ruby! "--- пожалуй, самый сложный в дереве портов; он даже получил персональную man-страницу: \linebreak\v!ruby"=module!(5). С его помощью собираются как обычные программы, зависящие от Ruby, так и Ruby gems, с платформо-зависимым кодом и без. Из возможностей модуля:
\end{enumerate}

\begin{itemize}
  \item Поддержка использования одним портом различных версий Ruby (включая JRuby и Rubinius) через механизм опций.
  \item Санация путей к интерпретатору Ruby в скриптах (замена \texttt{\#!/usr/bin/env} или \texttt{\#!/usr/bin/ruby} на то, с чем должен работать порт).
\end{itemize}

Функциональность, подобная описанной выше, присутствует и в других аналогичных модулях: \v!lang/python!, \v!lang/tcl!\ldots{}

О ручном контроле версий разделяемых библиотек:

Речь здесь пойдёт о самих библиотеках как объектах компиляции, а не о дистрибутивах ПО. Также следует сказать, что нижесказанное относится лишь к «публичным» библиотекам, которые используются при компиляции ПО. Всевозможные плагины и им подобные сущности не используются при компиляции, а загружаются динамически, посредством \v!dlopen()!, и располагаются в отдельных подкаталогах.

Для разделяемых библиотек существует соглашение о нумерации: \v!MAJOR.MINOR[.OTHER\ldots{}]!, со следующими правилами изменения версии:

\begin{itemize}
  \item Изменение в библиотеке, приводящее к изменению ABI без сохранения обратной совместимости: увеличение MAJOR.
  \item Изменение в библиотеке, не приводящее к изменению ABI, или же сохраняющее обратную совместимость ABI: увеличение MINOR.
\end{itemize}

Номер версии записывается в имени файла и/или в SONAME библиотеки. Когда требуется найти подходящую для программы версию библиотеки, поиск осуществляется с учётом вышеуказанного соглашения: MAJOR должна совпадать с тем, что требуется программе, а MINOR "--- быть не меньше требуемого программой. Казалось бы, всё довольно просто, но:

\begin{itemize}
  \item Часто разработчики смешивают версию дистрибутива, поставляющего библиотеку, с её внутренним номером. В результате, смена внутреннего номера библиотеки находится в полном отрыве от реальности.
  \item В других случаях не производится изменение внутреннего номера библиотеки, или изменяется не та часть номера. В результате, после обновления установленной версии библиотеки, использующее её ПО может оказаться неработоспособным.
  \item Наконец, иногда в самой операционной системе могут происходить изменения, влияющие на ABI. В случае OpenBSD, правда, обычно делается увеличение MAJOR для libc, что автоматически «разделяет» разные поколения пакетов.
\end{itemize}

В силу вышеперечисленных причин, в OpenBSD введена практика использования собственной нумерации разделяемых библиотек. Ответственность за соблюдение правил ABI в этом случае ложится на того, кто подготавливает порт или его обновление. Это может показаться большим усложнением, однако на самом деле для всех популярных систем сборки в OpenBSD имеется поддержка перекрытия версий библиотек. Внешне эти изменения сводятся к следующему: когда система сборки готовится слинковать конечную версию библиотеки libfoo, то проверяется наличие переменной окружения \v!LIBfoo\_VERSION! и, если такая установлена, использует её значение вместо заданного в конфигурации сборки разработчиком. Таким образом, максимум, что приходится делать при подготовке (обновления) порта "--- это второй раз его собрать, если были пропущены какие-то библиотеки; обычно инфраструктура портов сама обнаруживает и уведомляет о таковых при выполнении операции «\v!make update-plist!».

Версии разделяемых библиотек играют большую роль при обновлении ПО, так как позволяют осуществлять плавную миграцию между версиями использующего библиотеки ПО.

\end{document}
