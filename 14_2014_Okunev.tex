\documentclass[10pt, a5paper]{article}
\input{preamble.tex}
\begin{document}
\title{clsync progess: security and porting to FreeBSD}
\author{Дмитрий Окунев, Москва, РФ\footnote{\url{xaionaro@gmail.com}, \url{http://lvee.org/ru/abstracts/138}}}
\maketitle
\begin{abstract}
The report focuses on methods to increase a level of security of "clsync" (free live sync utility). Multiple approaches to reduce risks of attack were used, and practical experience of applying these approaches is given. Used methods include unsharing un\-necessary resources, splitting the process to privileged and non"=privileged threads and using Linux"=specific security"=related API. Also problems of porting Linux"=based clsync to FreeBSD are described, including variants and problems of FS monitoring in FreeBSD.
\end{abstract}
\subsection*{Введение}

Проект clsync возник как альтернативный высокопроизводи"=\linebreak тельный инструмент для синхронизации контейнеров LXC между узлами HA"=кластера и их резервного копирования, изначально ориентированный под внутренние нужды отдела UNIX"=технологий НИЯУ МИФИ \cite{Okunev1}, \cite{Okunev2}. Данная статья является отчётом о достижениях по развитию программы «clsync» в вопросах повышения уровня безопасности и портируемости на другие ОС в 2014 году.

\subsection*{Средства защиты}

Процесс отслеживания изменений на ФС часто требует  привилегий root (или capability «CAP\_DAC\_READ\_SEARCH» \cite{Okunev3} в Linux). Однако известные программы \cite{Okunev4} для синхронизации на базе inotify \cite{Okunev5} имеют достаточно малое сообщество и при этом не имеют никаких встроенных механизмов повышения безопасности (сброс лишних привилегий, namespaces и т.п.). В результате становится маловозможной настройка синхронизации посредством inotify в системах, требующих особой защиты. Далее будут рассмотрены средства для минимизации последствий эксплуатации уязвимостей, реализованные в «clsync» летом 2014"=го года.

\subsubsection*{Задача}

Задача заключается в минимизации последствий обнаружения и эксплуатации уязвимостей в clsync злоумышленником.

Предполагается, что:

\begin{itemize}
  \item Необходимо предоставить процессу «clsync» полный доступ к некоторому файловому дереву, содержащему объекты (файлы, директории и т.п.) с произвольными наборами прав.
  \item Злоумышленник имеет возможность управлять содержимым данного файлового дерева, но не имеет других путей для манипуляции над процессом «clsync».
  \item «clsync» не наблюдает за файлами, чтение которых злоумышленником привело бы к ущербу.
  \item Процессу «clsync» необходимо запускать внешний процесс (например «rsync») для осуществления синхронизации.
\end{itemize}

Практическим применением данной задачи является хостинг на базе LXC, требующий синхронизации на другой узел для реализации High Availability \cite{Okunev1, Okunev6}. А для синхронизации запускается по одному процессу «clsync» на каждый контейнер. В такой конфигурации содержимым контейнера управляют малодоверенные пользователи, которые могут иметь интерес выйти за пределы предоставленных им пространств имен (namespaces), эксплуатируя уязвимость в «clsync» (который в свою очередь запущен с хост"=системы, то есть извне пространств имен контейнера).

\subsubsection*{Решение}

В качестве мер для повышения безопасности предлагается:

\begin{itemize}
  \item Применить unshare() \cite{Okunev7} для отсоединения от пространств имен хост"=системы для сети, IPC и других ресурсов.
  \item Сбросить привилегии с помощью setuid()/setgid(), предварительно сохранив capability «CAP\_DAC\_READ\_SEARCH» \linebreak для сохранения полного доступа к файловому дереву.
  \item Производить chroot(), pivot\_root() \cite{Okunev8} и umount() для запрета доступа к файлам вне наблюдаемой директории.
  \item Разделять процесс на «большой непривилегированный» и «малый привилегированный».
  \item Использовать seccomp filter \cite{Okunev9} для запрета лишних системных вызовов (syscalls) внутри непривилегированного потока.
\end{itemize}

\paragraph{unshare().}

Применение unshare() позволяет запретить доступ к сети (и сервисам, работающим на localhost), IPC и другим ресурсам. Это необходимо, чтобы предотвратить взлом процессов по цепочке (когда злоумышленник пытается взламывать другие сервисы через уязвимость clsync).

\paragraph{Сброс привилегий.}

Сброс привилегий "--- тривиальная и очень распространенная процедура. В «clsync» предлагается производить сброс с помощью setuid() и setgid() с предварительным сохранением capability «CAP\_DAC\_READ\_SEARCH» для доступа к файлам. Однако в рамках сформулированной задачи необходимо решить следующие проблемы:

\begin{enumerate}
  \item Запускаемому процессу для синхронизации (например, \linebreak «rsync») аналогично необходим доступ на чтение всего синхронизируемого файлового дерева. И наследовать для этого capability «CAP\_DAC\_READ\_SEARCH» недостаточно, так как кроме этого необходимо его активировать (добавить в effective capabilities bitmask). Но такого рода процессы обычно не имеют поддержки активации capabilities. Поэтому данную проблему необходимо решить возможностями «clsync». Для решения данной проблемы можно либо добавить в связку sudo (или аналог), или делать setuid()/setgid() назад на root. Использование дополнительного ПО существенно снижает уровень безопасности, поэтому setuid()/setgid() является более желательным вариантом. Но сохранение capabilities «CAP\_SETUID» и «CAP\_SETGID» фактически полностью ликвидирует защиту за счёт сброса привилегий. Чтобы решить данную проблему предложен способ разделения процесса на «большой привилегированный» и «малый непривилегированный».
  \item «CAP\_DAC\_READ\_SEARCH» предоставляет доступ на чтение всех файлов, что недопустимо в рамках сформулированной задачи. В качестве решения проблемы предлагается использовать chroot(), pivot\_root() и umount().
\end{enumerate}

\paragraph{Namespace файлового дерева.}

Как уже говорилось, для запрета доступа к файлам вне наблюдаемой директории предлагается использовать pivot\_root(), chroot() и umount(). В автоматической форме это делается по следующему алгоритму:

\begin{enumerate}
  \item Открепление от namespace точек монтирования с помощью unshare().
  \item Монтирование chroot"=окружения в отдельную директорию с помощью bind (с опцией режима «только на чтение»).
  \item Переход в данную директорию.
  \item Вызов pivot\_root() для последующего отмонтирования rootfs хост"=системы.
  \item Вызов chroot() на данную директорию.
  \item Отмонтирование старого rootfs (что спровоцирует каскадное отмонтирование всех лишних точек монтирования).
\end{enumerate}

Данный подход даёт возможность достаточно надёжно защитить лишние файлы от чтения/изменения процессом «clsync». Однако существует риск, вызванный уязвимостью, описанной в статье \cite{Okunev10}. Данная проблема решается за счёт разделения процесса на «большой непривилегированный» и «малый привилегированный».

\paragraph{Splitting.}

Технически разделение процесса «clsync» на «большой непривилегированный» и «малый привилегированный» предполагает запуск дополнительного потока (thread) для обращения к системным вызовам, требующим привилегий выше чем «nobody». С точки зрения безопасности, это способ многократно снизить площадь для атаки на clsync. Если предположить, что потенциальные уязвимости распределены по всему коду равномерно, то данный подход позволяет ликвидировать последствия взлома почти полностью для более чем 90\% уязвимостей, и чем меньше будет код привилегированного потока, тем выше окажется эффективность метода. Однако данный подход требует применения блокировок и передачи сообщений между потоками, что существенно снижает производительность (время выполнения увеличивалось в несколько раз).

Для уменьшения потерь производительности был реализован механизм блокировок, комбинирующий pthread\_mutex\_* и spinlock, что позволило достичь на многоядерных системах времени выполнения близкого к прежнему (без данного разделения потоков), но со значительно большим расходом ресурсов CPU.

Однако, так как разделение производится при помощи pthread, то у непривилегированного потока есть доступ ко всей памяти привилегированного потока, включая доступ к stack и т.п. Это позволяет без особых сложностей провести атаку на привилегированный поток из непривилегированного. Чтобы решить данную проблему, предлагается использовать seccomp filter для запрета вызова mprotect из непривилегированного потока, а также «забыть» максимальное количество информации о привилегированном потоке. Если первое является реальным средством защиты, то второе "--- лишь способ усложнить эксплуатацию потенциальной уязвимости.

\paragraph{Seccomp.}

Seccomp, как уже было сказано выше, предлагается использовать для фильтрации лишних системных вызовов для непривилегированного потока, что позволяет:

\begin{itemize}
  \item защитить привилегированный поток с помощью mprotect \cite{Okunev11}.
  \item дополнительно снизить последствия эксплуатации уязвимости, так как набор действий злоумышленника будет ограничен до конкретного короткого списка системных вызовов.
\end{itemize}

\subsection*{Портирование на FreeBSD}

FreeBSD (как и другие BSD"=системы) до сих пор активно используются для реализации различных сервисов высокой доступности, однако в стандартном дереве портов данной ОС не предоставляется никаких production"=ready решений для живой синхронизации файлов (без использования специальных файловых систем). Далее будет описаны основные проблемы при портировании программы для живой синхронизации «clsync» под FreeBSD.

Оригинальный «clsync» использует inotify для наблюдения за ФС, однако данный API специфичен для Linux и не предоставляется во FreeBSD. В результате при портировании в качестве альтернатив для наблюдения за событями на ФС были выбраны «kqueue» \cite{Okunev12}, «bsm» \cite{Okunev13} и «dtrace» \cite{Okunev14}.

Основными проблемами при использовании «kqueue» являются:

\begin{itemize}
  \item использование большого количества файловых дескрипторов (в сравнении с inotify);
  \item невозможность получать детали по создаваемым файлами и директориям (что было решено полным пересканированием директории при появлении в ней нового объекта);
  \item необходимость «вручную» вычислять переносы файлов и директорий (и различать их с созданием жестких ссылок, т.е. hard links);
  \item множество сложноучитываемых эффектов (например, необходимо учитывать, что нельзя открывать pipes).
\end{itemize}

Основной проблемой при использовании «bsm» является требование глобальной перенастройки auditd.

А «dtrace», как выяснилось в ходе реализации его поддержки в «clsync», реализован не в соответствии с оригинальным «dtrace» \cite{Okunev15}. Причем различия построенным таким образом, что становится очень затруднительным получить полный путь файла, которому соответствует пойманное событие. В результате, реализация «dtrace» во FreeBSD непригодна для наблюдения за событиями ФС.

На данный момент самая стабильная работа clsync во FreeBSD обеспечена с применением библиотеки libinotify"=kqueue \cite{Okunev16}, которая представляет собой реализацию API inotify на базе kqueue.

\begin{thebibliography}{9}
  \bibitem{Okunev1} Окунев Д.Ю. «clsync — live sync utility», материалы Международная конференция разработчиков и пользователей свободного программного обеспечения Linux Vacation / Eastern Europe (LVEE Winter 2014), \url{http://lvee.org/en/reports/materials_lvee_winter_2014}
  \bibitem{Okunev2} «file live sync daemon based on inotify, written in GNU C», \url{https://github.com/xaionaro/clsync}
  \bibitem{Okunev3} \url{http://linux.die.net/man/7/capabilities}
  \bibitem{Okunev4} «Manual to Lsyncd 2.1.x», \url{https://github.com/axkibe/lsyncd/wiki/Manual-to-Lsyncd-2.1.x}
  \bibitem{Okunev5} «inotify – monitoring file system events», \url{http://linux.die.net/man/7/inotify}
  \bibitem{Okunev6} Окунев Д.Ю. «Опыт внедрения отказоустойчивого web-кластера для портала приёмной комиссии НИЯУ МИФИ», научная сессия НИЯУ МИФИ, 2012, \url{http://www.pandia.ru/text/78/343/297.php}
  \bibitem{Okunev7} \url{http://linux.die.net/man/2/unshare}
  \bibitem{Okunev8} \url{http://linux.die.net/man/2/pivot_root}
  \bibitem{Okunev9} \url{http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/prctl/seccomp_filter.txt}
  \bibitem{Okunev10} «Выявлена уязвимость, позволяющая выйти за пределы контейнеров Docker», \url{http://www.opennet.ru/opennews/art.shtml?num=40046}
  \bibitem{Okunev11} «mprotect -- set protection on a region of memory», \url{http://linux.die.net/man/2/mprotect}
  \bibitem{Okunev12} «kqueue, kevent — kernel event notification mechanism», \url{http://www.freebsd.org/cgi/man.cgi?query=kqueue&sektion=2}
  \bibitem{Okunev13} «auditd — audit log management daemon», \url{http://www.freebsd.org/cgi/man.cgi?query=auditd&sektion=8}
  \bibitem{Okunev14} «dtrace — DTrace dynamic tracing compiler and tracing utility», \url{http://www.unix.com/man-page/freebsd/1/dtrace/}
  \bibitem{Okunev15} «DTrace Built-in Variables», Oracle, \url{http://docs.oracle.com/cd/E18752_01/html/819-5488/gcfpz.html}
  \bibitem{Okunev16} «NetBSD Google Summer of Code 2011 project (\#2)», \url{https://github.com/dmatveev/libinotify-kqueue}
\end{thebibliography}

\end{document}
