\documentclass[10pt, a5paper]{article}
\input{preamble.tex}
\frenchspacing
\begin{document}
\title{Perl 6 Pod "--- формат ведения документации}
\author{Александр Загацкий\footnote{Витебск, Беларусь, \url{http://zag.ru}, \url{me@zag.ru}}}
\date{}
\maketitle

\begin{abstract}
Pod is an evolution of Perl 5's POD markup. Compared to POD, Perl 6's
Pod is much more
uniform, somewhat more compact, and considerably more
expressive. Established in 2005, specification
has undergone several revisions and is currently stable. The
specification is written in Perl 6 Pod and is a
good means of testing the implementations.
There are several imple\-men\-ta\-tions in Perl 5 and Perl 6.
Presentation covers the differences from Perl 5 POD, key features and 
experience of Perl 6 Pod personal usage.
\end{abstract}

Формат разметки Perl 6 Pod перестал быть черновиком. В финальной версии
спецификации Synopsis 26 \cite{zag1pod} добавился ряд особенностей.
Никогда не еще не было настолько тесной интеграции программного кода и
документации к нему.

Так, добавился специальный тип блоков документации --- блоки-деклараторы.
Данные блоки предваряются специальным комментарием \verb!#=!, за которым
следует текст документации. Оформленные блоки документации ассоциируются
с делараторами подпрограмм, а так же переменных. Уникальной особенностью
является тот факт, что эти блоки документации становятся доступными
через специальный атрибут \verb!.WHY!. Например:

\begin{verbatim}
 sub fu (           #= This text stored in &fu.WHY
  Any     $bar,    #= This text stored in $bar.WHY
  Mode    :$baz   #= This text stored in $baz.WHY
    ) { ... }

 #= This is a special chainsaw
 my SwissArmy $chainsaw    #= (It has a rocket launcher)

 say $chainsaw.WHY; # prints: This is a special chainsaw
                   #         (It has a rocket launcher)
\end{verbatim}


В приведенном примере текст документации к переменной \linebreak \verb!$chainsaw!
становится доступным из программного кода. В указанном примере блок кода
будет выведен на экран:
\begin{lstlisting}[language={Perl}]
 say $chainsaw.WHY; # prints: This is a special chainsaw
                   #         (It has a rocket launcher)
\end{lstlisting}

Уникальна сама концепция, а именно доступ программного кода к
документации по нему. То есть становится возможным менять логику
программы в зависимости от описанной в документации!

Еще одним примером интеграции документации и кода являются
контекстуальные псевдонимы. Для их определения используется директива
\verb!=alias!. Например:
\begin{lstlisting}[language={Perl}]
 # This is actual code...
 sub hash_function ($key)
 *=alias HASHCODE*
 {
    my $hash = 0;
    for $key.split("") -> $char {
        $hash = $hash*33 + $char.ord;
    }
    return $hash;
 }
	   \end{lstlisting}

В данном примере определяется псевдоним HASHCODE. Его значением
является следующий за ним программный блок. Теперь, чтобы привести в
документации пример кода достаточно указать имя псевдонима внутри кода
форматирования \verb!A<>!:
\begin{lstlisting}[language={Perl}]
 =begin pod
 An ancient (but fast) hashing algorithm is used:
 =begin code :allow<A>
  A<HASHCODE>
 =end code
 =end pod
\end{lstlisting}

В результате в документации будет вставлен блок кода из программы:
\begin{lstlisting}[language={Perl}]
 An ancient (but fast) hashing algorithm is used:

    my $hash = 0;
    for $key.split("") -> $char {
        $hash *= 33;
        $hash += $char.ord;
    }
    return $hash;
	   \end{lstlisting}

Это позволяет избежать ручного копирования блоков кода и последующую
актуализацию документации.


\begin{thebibliography}{9}
	\bibitem{zag1pod} Спецификация формата Pod (Synopsis 26). \url{https://github.com/zag/specs/raw/master/S26-documentation.pod}
\end{thebibliography}

\end{document}
