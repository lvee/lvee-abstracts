\documentclass[10pt, a5paper]{article}
\input{preamble.tex}

\begin{document}

\title{Подходы к статическому анализу открытого исходного кода}%\footnote{Текст данных и последующих тезисов, кроме специально оговоренных случаев, доступен под лицензией Creative Commons Attribution-ShareAlike 3.0}

\author{Зубов М.~В., Старцев Е.~В., Пустыгин А.~Н.\footnote{ЧелГУ, Челябинск, РФ}}
\maketitle

\begin{abstract}
This paper presents current existing approaches of using programs's representations for static analysis. This analysis can help to understand and extend open-source software. The most common approaches were implemented in prototypes with open technologies. Also class-level detailed representation was developed and implemented in prototype to prove the assumption of more effective analysis on less detailed representation.
\end{abstract}

Статический анализ  --- - анализ кода, проводимый без его исполнения. Это достаточно мощный инструмент, который можно использовать во многих целях: от обнаружения ошибок до получения информации об использованных алгоритмах. Для выполнения статического анализа обычно формируют промежуточные представления исходного кода.

Форма промежуточного представления может определяться целью анализа. В свободном проекте BLAST \cite{Zubov1} исходный код программы представляется виде автомата потока управления (CFA), описывающего набор состояний процедур и переходы между ними. Алгоритм анализа называется <<абстракция и уточнение по  контрпримерам>>: создаются абстрактные деревья достижимости (ART), которые описывают возможные пути распространения управления на уровне общности, которая используется на очередной итерации алгоритма.

Наиболее распространенное промежуточное предсталение — абстрактное дерево синтаксического разбора Abstract Syntax Tree (AST) \cite{Zubov2}. Известные инструменты генерации парсеров, такие как ANTLR \cite{Zubov3} (используется в Checkstyle \cite{Zubov4} для языка Java) или специфичные инструменты, например, API компилятора Compass/ROSE (ROSE) \cite{Zubov5}, поддерживающего языки C, C++ и Fortran, могут быть использованы для генерации AST. Этот подход является простым и проверенным временем. Однако, имеют место и другие подходы. Например, в проекте Pylint \cite{Zubov6} для языка Python может быть использован отдельный свободно-распространяемый модуль logilab-astng \cite{Zubov7}. Авторами были разработаны 2 прототипа генератора промежуточных представлений, основанных на AST: первый, для языка Python --- на основе свободного модуля logilab-astng \cite{Zubov7}, второй, для Java --- на основе компилятора javac, входящего в состав открытой реализации средств разработки на Java --- OpenJDK \cite{Zubov8}.

Другой вариант использования промежуточного представления --- реляционное представление исходного кода анализируемого ПО. По грамматике исходного языка подготавливается схема реляционной базы данных, далее созданная по этой схеме база данных заполняется в соответствии с конструкциями исходного кода. Анализ сводится к выполнению произвольных запросов к этой базе. В инструментах, использующих такой тип представления, применяются различные языки запросов, как самостоятельные, например, QUEL \cite{Zubov9} (в OMEGA \cite{Zubov10} для Ada, C и Pascal), так и специально созданные, например, .QL \cite{Zubov11} (SemmleCode \cite{Zubov12} для Java). В настоящее время ведется создание прототипа построителя реляционного промежуточного представления для языка Java. Применение такого представления будет очень эффективно на больших объемах данных. Идея представления в виде реляционной БД дополняется использованием логических языков в качестве языков запросов (Prolog в ASTLOG\cite{Zubov13}, Datalog в CodeQuest\cite{Zubov14}), более подходящих для анализа структур исходного кода, например, транзитивных замыканий. Запросы к базе знаний транслируются в SQL и выполняются на конкретной базе данных, либо же база данных может быть представлена в виде базы знаний. На практике используется только первый способ.

Из идей реляционного представления, а именно проведения анализа в виде выполнения запросов к исходному коду, выделилось отдельное направление. Оно стоит обособленно, так как не диктует использование конкретного представления. Оно может быть как реляционным в системе CodeQuest \cite{Zubov14}, так и AST в ASTLOG \cite{Zubov13}. Некоторые заявляют о потенциально любом представлении (PQL \cite{Zubov15}). В основном, в концепции запросов к исходному коду используют логические языки как наиболее удобные и нацеленные на извлечение знаний. Известны также анализаторы, выполняющие запросы на естественном языке (английском) \cite{Zubov16}.

Промежуточные представления можно классификацировать по уровню детализации. Так в академическом проекте Bauhaus project \cite{Zubov17} для языков Ada, C, C++, C\# и Java имеются 2 представления --- низкоуровневое InterMediate Language, описывающее конструкции языка на синтаксическом и семантическом уровнях, и Resource flow graphs, описывающее архитектурные особенности программной системы. В анализаторе, использующем PQL \cite{Zubov15}, выделяется 3 уровня анализа: модель глобального программного дизайна, модель структуры программы, модель детального программного дизайна. Для создания прототипа такого представления был выбран средний уровень детализации --- уровень структуры и связи классов.

Очевидно, что на разных уровнях детализации могут быть эффективны различные представления. Так, например, граф потока управления будет иметь не слишком сложную структуру, но очень большой объем, поэтому для него логично бы было использовать реляционное представление. При работе с любым представлением исходного текста на любом уровне необходимо сохранять возможность соотнести анализируемый объект с местом в исходном коде, в котором он описан. Это достигается сохранением координат объектов в представлениях, как и было реализовано в представлении уровня классов.

Если промежуточное представление может описывать сразу несколько входных языков, то оно называется универсальным или мультиязычным. Оно позволяет производить типовые процедуры анализа для различных языков, упрощая задачу построения анализаторов. Но из его достоинства следует и недостаток, учитывать все детали конкретного языка оказывается невозможным. В качестве прототипа универсального представления было реализовано представление уровня структуры классов для языков Python и Java на основе прототипов генерации частных представлений уровня AST.

За счет универсальности категорий ООП, существующих во всех объектных языках \cite{Zubov18}, полученное представление является полным для своего уровня анализа и, в то же время, универсальным для объектно-ориентированных языков. Полученное высокоуровневое представление позволяет производить анализ на уровне классов и архитектуры проекта, что позволяет снизить накладные расходы на выполнение анализа по сравнению с более детализированным представлением.

Независимо от форм представлений можно выделить модель анализа с помощью моделей отражения \cite{Zubov19}. Она основана на сравнении высокоуровневой модели программы, которую программист мыслит себе в процессе разработки, и фактической, полученной в результате. Этот подход не требует конкретного представления кода, и иногда может быть выполнен с использованием текстовой обработки. Так, в частности, он был реализован в одном из первых опытов применения подхода для изучения подсистемы виртуальной памяти NetBSD \cite{Zubov19}. На основе этого подхода с помощью собственного генератора промежуточного представления для Python, использующего logilab-astng \cite{Zubov7}, была построена и проанализирована высокоуровневая модель нескольких проектов с открытым исходным кодом на Python.

\begin{thebibliography}{99}

\bibitem{Zubov1}BLAST / \url{mtc.epfl.ch/software-tools/blast/index-epfl.php}
\bibitem{Zubov2}Ахо А.В., Ульман Д.Д. / Компиляторы. Принципы, технологии и инструментарии. / М.: Вильямс, 2008г.
\bibitem{Zubov3}ANTLR / \url{www.antlr.org}
\bibitem{Zubov4}Checkstyle / \url{checkstyle.sourceforge.net}
\bibitem{Zubov5}ROSE / \url{rosecompiler.org}
\bibitem{Zubov6}Pylint / \url{www.logilab.org/857}
\bibitem{Zubov7}logilab-astng / \url{www.logilab.org/856}
\bibitem{Zubov8}OpenJDK / \url{openjdk.java.net}
\bibitem{Zubov9}Ingres 10.0 QUEL Reference guide / Ingres corp. 2010, code.ingres.com/ingres/main/src/tools/ techpub/pdf/QUELRef.pdf
\bibitem{Zubov10}M. Linton / Queries and Views of Programs Using a Relational Database System / www.eecs.berkeley.edu/Pubs/TechRpts/1983/5296.html
\bibitem{Zubov11}O. de Moor, E. Hajiyev, M. Verbaere / Object-oriented queries over software systems / ACM Press, 2007.
\bibitem{Zubov12}SemmleCode / semmle.com/solutions/enabling-tools-for-your-projects
\bibitem{Zubov13}R. Crew / ASTLOG: A Language for Examining Abstract Syntax Trees / Microsoft Research, 1997.
\bibitem{Zubov14}E. Hajiyev / CodeQuest --- Source Code Querying with Datalog / St. Anne’s College, Oxford University, 2005.
\bibitem{Zubov15}S. Jarzabek / Design of Flexible Static Program Analyzers with PQL / IEEE Transactions on software engineering, vol. 24, no. 3, march 1998.
\bibitem{Zubov16}M. Kinmming, M. Monperrus, M. Mezini / Quering Source Code with Natural Language / 26th IEEE/ACM International Conference On Automated Software Engineering (ASE'2011).
\bibitem{Zubov17}Bauhaus project / \url{www.bauhaus-stuttgart.de/bauhaus/index-english.html}
\bibitem{Zubov18}И. Грэхем / Объектно-ориентированные методы. Принципы и практика / М.: Вильямс, 2004 г.
\bibitem{Zubov19} G.C. Murphy, D. Notkin, K. Sullivan / Software Reflexion models: Bridging the gap between source and high-level models / Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, pages 18--28, New York, ACM Press, 1995.

\end{thebibliography}

\end{document}




