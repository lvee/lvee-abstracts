\documentclass[10pt, a5paper]{article}
\input{preamble.tex}

\begin{document}

\title{Managing over 9000 nodes with Puppet}%\footnote{Текст данных и последующих тезисов, кроме специально оговоренных случаев, доступен под лицензией Creative Commons Attribution-ShareAlike 3.0}

\author{Василий Михаленя\footnote{Минск, Беларусь}}
\maketitle

\begin{abstract}
The review of Puppet, an open source tool for managing configurations. This article describes its features, advantages, scalability, common and best practices. <<SSH in a for loop is not a solution>> (Luke Kanies, Puppet developer)
\end{abstract}

\section*{Что такое puppet}

Puppet "--- клиент"=серверное приложение для удобного распространения конфигураций "--- состоит из puppetmaster'а, сервера хранящего конфигурации, и puppet agent'а, работающего на конфигурируемом сервере. Puppet написан на ruby, распространяется под лицензией Apache и содержит возможности расширения функциональности с использованием ruby. Проект имеет ruby в качестве единственной зависимости, работает на Linux, Solaris, BSD, Mac OS X, поддерживает Microsoft Windows. Puppet можно использовать как для документирования конфигурации на одном сервере, так и для легкого управления конфигурацией парка серверов в гетерогенной среде. Puppet используют такие проекты как wikimedia, twitter, digg, sugarcrm и многие другие.

\section*{Основные примитивы языка. Puppet vs bash}

Описание конфигураций происходит на своем собственном декларативном языке. Декларативный язык позволяет описать желаемое состояние системы в зависимости от набора фактов "--- описание <<как именно делать>>, как правило, не требуется. Если применять некоторую конфигурацию на серверах с разными ОС (или, например, разными дистрибутивами Linux), используя bash скриптинг, получаем трудноподдерживаемый код. Puppet же позволяет быть уверенным не только в том, что изменения были применены единоразово ( случай shell"=сценариев), но и что текущее состояние соответствует описанному. Простота языка позволяет использовать манифесты puppet как понятную документацию конфигурации систем.

К числу основных понятий языка относятся следующие:

\begin{itemize}
  \item ресурсы "--- file, package, user, exec, cron и т.д.
  \item классы "--- объединения ресурсов и зависимости между ними
  \item модули "--- самостоятельные наборы классов, например, для конфигурации определенного сервиса. Модули независимы и могут распространяться отдельно.
  \item факты "--- facts "--- пары <<ключ"=значение>>, которыми оперирует puppet для выбора конфигурации (например, hostname =\textgreater{} mars, is\_virtual =\textgreater{} false, operatingsystem =\textgreater{} Ubuntu, processorcount =\textgreater{} 8).
  \item ноды "--- nodes "--- соответствие имени сервера (ноды) и набора классов, которые будут к ней применены. Возможно хранение нод в LDAP или использование внешнего классификатора нод "--- произвольного скрипта.
  \item манифест "--- конфигурационный файл puppet, в котором описаны ресурсы, классы, модули или ноды
\end{itemize}

\section*{Управление парком машин от 2 до бесконечности}

Очевидно, что преимуществ от автоматизации применения конфигурации тем больше, чем больше систем и сервисов на них настраиваются с помощью puppet. Но некоторые вещи полезно автоматизировать, если имеются хотя бы 2 ноды:

\begin{itemize}
  \item синхронизация authorized\_keys
  \item синхронизация пользователей и/или их настроек (bashrc, vimrc \ldots{})
  \item синхронизация правил брандмауэра
  \item и т.д.
\end{itemize}

В гетерогенной среде приходится учитывать <<факты>> в своих конфигурациях. Деплоймент новой или вышедшей из строя ноды происходит в течение нескольких минут при достаточной степени полноты описания конфигурации. Существует огромное количество написанных модулей для практически любых сервисов (их список можно получить поиском, например, на github). Деплоймент или применение каких"=либо изменений для 2 или 2000 нод практически не отличаются по трудоемкости при грамотном подходе.

\section*{Как работает puppet}

Puppet agent раз в 30 минут запрашивает конфигурацию у puppetmaster:

\begin{enumerate}
  \item Компиляция манифеста происходит на сервере, результатом являются <<базовые хеши>> и никакой валидации данных.
  \item Инстанциирование "--- конвертация <<базовых хешей>> и массивов, полученных при компиляции, в объекты puppet"=библиотеки. Валидация входных данных происходит на данном этапе.
  \item Конфигурирование "--- сравнение каждого описанного ресурса с реальным положением дел, и внесение соответствующих изменений при необходимости.
\end{enumerate}

Также существует подход nodeless (masterless). При данном подходе, манифеста с описанием нод не существет "--- мастер не нужен, вся конфигурация копируется на ноду, а настройка опирается исключительно на <<факты>>.

\section*{Как масштабировать puppet}

До 100 нод со стандартным периодом в 30 минут могут успешно работать с единственным puppetmaster"=сервером (WEBRick Ruby"=based HTTP). Дальше начинаются проблемы. Выход "--- связка mod\_passenger + apache + rack. При данной схеме возможно распределение нагрузки на несколько серверов. Часто используют подход со splay time "--- размазывание по времени нагрузки на мастер "--- при котором все ноды не должны обращаться к мастеру одновременно. Можно также использовать подход 1 мастер на площадку (сайт), с синхронизацией между площадками, например, через тот же git.

\section*{Опыт работы в команде}

Опыт работы над <<рецептами>> puppet подсказывает использовать следующие практики:

\begin{itemize}
  \item Использование environments "--- различных наборов манифестов для разработки и продакшна, когда выбор environment'a происходит на стороне клиента.
  \item Использование системы контроля версий "--- например, git. Очень удобным оказывается использование двух различных веток или репозиториев, для разработки и продакшна соответсвенно.
\end{itemize}



\end{document}




