\documentclass[10pt, a5paper]{article}
\input{preamble.tex}
\switchlang{en}
\begin{document}
\title{Hidden powers of screen and xterm: multiple windows inside of a terminal}
\author{Andrew Savchenko, Moscow, Russian Federation}
\maketitle
\begin{abstract}
Xterm and screen are both well known software, but they are more powerful than they look like at a first glance. This talk reveals some of their not so widely used features which may increase productivity, improve user experience or are just fun. Some problems and their solutions are also discussed.
\end{abstract}

\lstset{ %
language=C,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
}

\subsection*{XTerm}

Default xterm looks unpleasantly in most distributions: small, barely readable fonts, no multiple tabs or CJK~\cite{Savchenko1} support. Thus many users disregard it, though it is one of the most powerful applications if tuned properly.

All numerous features of XTerm can be tuned via X Resources. Ways of providing them depend on WM and distribution, but portable way is to run (file name may be arbitrary):
\verb@xrdb ~/.Xresources@

\subsubsection*{Fonts}

Arbitrary TTF font of your liking may be set using following \linebreak resources:

\begin{verbatim}
xterm*faceName: DejaVu Sans Mono:style=Bold
xterm*faceSize: 15
\end{verbatim}
On some fonts and sizes symbols like <<\_>> may be unreadable, to correct this use:
\verb@xterm*scaleHeight: 1.01@

Let's add some CJK love (double size glyphs CJK font and 4-byte width symbols):

\begin{verbatim}
XTerm*combiningChars: 4
XTerm*faceNameDoublesize: mikachan
\end{verbatim}
Of course, CJK must be properly configured, e.g.:

\begin{verbatim}
export GTK_IM_MODULE=uim
export QT_IM_MODULE=uim
export XMODIFIERS=\@im=uim
uim-xim --engine=anthy-utf8 &
\end{verbatim}

\subsubsection*{Colors}

256-color palette can be enabled: 
\verb@xterm*termName:@\linebreak
\verb@ xterm-256color@

Custom RGB colors configuration:

\begin{verbatim}
xterm*color1:    rgb:b2/18/18
xterm*color2:    rgb:18/b2/18
...
\end{verbatim}

It is possible to replace bold and underline attributes by color:

\begin{verbatim}
xterm*colorBDMode: True
xterm*colorBD: magenta3
xterm*colorULMode: True
xterm*colorUL: cyan3
\end{verbatim}

\emph{Limitation:} if locale is not UTF-8 and wide chars (CJK) are used, 256 colors are not available due to limited number of XResources.
\emph{Solution:} use UTF-8!

Dynamic colors change (for already printed text) can be done using escape sequence:\linebreak
\verb@\033]<target>;#RRGGBB\007@

E.g. to set background to \#1818B2 (marine blue):\linebreak
\verb@echo -ne "\033]10;#1818B2\007"@

For details about possible targets see ~\cite{Savchenko2}, example scripts are at ~\cite{Savchenko3}.

\subsection*{Screen}

GNU screen is a terminal manager, you may think of it like a window manager for terminals.

Why do you need that? There are so many terminals with multiple tabs and various features available\ldots{} Because of its client–server \linebreak architecture! It is possible to continue your work remotely, to survive broken ssh link like it was nothing and so on.

Screen server is started and stopped automatically and manages terminal sessions which can be attached and detached arbitrary by the user. This allows to connect both locally and via ssh from different hosts or interrupted connections.

Just start \emph{screen}, you'll have an ordinary terminal (in some \linebreak distributions you may see information info). It works like an ordinary terminal. All screen controls can be accessed via \emph{C-a-*} (\^{}A) sequence, e.g. \emph{C-a-c} will create new terminal, \emph{C-a-n} will switch to next one, \emph{C-a-p} will switch to previous terminal, C-a-" shows list of terminal windows available.

Screens can be detached from underlying terminal via \emph{screen -d} or \emph{C-a-d} and reattached using \emph{screen -r} or \emph{screen -RD} (with forced reattach first).

\subsubsection*{Configuration}

Tired of repeating \emph{C-a-*} here and there? Let's configure it to \linebreak something else. Screen's configuration lies in \~{}/.screenrc (though any file may be provided using -c option). The following option will bind \emph{C-a} (command sequence) to \emph{menu} key (on most common keyboards):

\begin{verbatim}
bindkey ^[[29~ command\end{verbatim}
But how to get that \emph{\^{}[[29\~{}} escape sequence? This little trick will help:
\verb@cat > /dev/null@
Now press any hotkeys you like and if they are not intercepted by other software (e.g. VM or DE), you will see their escape sequences.

This way 256 colors and bce (background color erase) can be enabled in screen:

\begin{verbatim}
term screen-256color-bce-s
defbce on\end{verbatim}
In screen each terminal window has its own history. It can be access via copy mode (\emph{C-a-ESC} or \emph{C-a-\emph{). It is possible to search within it (}C-S} for forward search, \emph{C-R} for backward direction), select and copy using \emph{space}, paste using \emph{C-a-]}. But default history depth is just 100 lines per windown. This can be fixed via:
\verb@defscrollback 3000@

\subsubsection*{Status line}

It is possible to configure status line showing date, time, list of windows, names of current directories per window and highlight an active one (and more information available for screen, see its man page for details).

This will create a simple status line with green on black [date(blue) time] in the right corner:
\verb@hardstatus string '%{=kG}%= @ \linebreak
\verb@ [%{B}%d/%m %{G}%0c:%s]'@
and always enable it an the bottom line: 
\verb@hardstatus alwayslastline@

Here things became more complicated: 
\verb@hardstatus string '%{@\linebreak
\verb@=kG}[%= %{= kw}%?%-Lw%?%{m}(%{W}%n*%f%t%?(%u)%?%{m})%{w}%?%@\linebreak
\verb@+Lw%?%?%= %{G}][%{B}%d/%m %{G}%0c]'@ 
To the right of date/time from previous example list of windows is added, active window is \linebreak highlighted and window title is being shown.

PS1 variable can be modified to truncate window name to 8 chars (or whatever you like) and collapse \textbackslash{}\$HOME to \~{}, so put something alike in bashrc:

\begin{lstlisting}
case \${TERM} in
...
	screen*)
		PROMPT_COMMAND='tmp="\${PWD/\$HOME/\~}"; tmp=\${tmp##*/}; [[ -z \$tmp ]] && tmp=/; echo -ne "\033k\${tmp:0:8}\033\\"; unset tmp'
		;;
esac
\end{lstlisting}

Now we have something yummy like shown on fig.1.

Moving around windows using \emph{menu-p}, \emph{menu-n} and \emph{menu-"} is still tiring. How about using arrows (\emph{S-right} and \emph{S-left}) for moving between windows and \emph{C-S-right}, \emph{C-S-left} to move windows themselves? The following lines does this:

\begin{verbatim}
bindkey ^[[1;2D prev
bindkey ^[[1;2C next
bindkey ^[[1;6D bumpleft
bindkey ^[[1;6C bumpright
\end{verbatim}
\subsubsection*{Troubleshooting}

Sometimes after su, sudo or ssh 256 color depth or bce are lost. This happens because \textbackslash{}\$TERM \textbf{and} \textbackslash{}\$TERMCAP environment variables are not passed. To fix this either reconfigure your software to pass \emph{and} accept these variables (look for ssh\_config SendEnv, sshd\_config AcceptEnv and so on) or set \textbackslash{}\$TERM properly and set \emph{bce on} in screen session.

\begin{thebibliography}{99}
\bibitem{Savchenko1} CJK is a collective term for the Chinese, Japanese, and Korean languages. \url{https://en.wikipedIA.org/wiki/CJK_characters} 
\bibitem{Savchenko2} fn2. \url{http://rtfm.etla.org/xterm/ctlseq.html}
\bibitem{Savchenko3} fп3. \url{http://rcr.io/words/dynamic-xterm-colors.html}
\end{thebibliography}
\end{document}
