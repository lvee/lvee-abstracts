\documentclass[10pt, a5paper]{article}
\input{preamble.tex}

\begin{document}

\title{<<Долгоиграющие>> базы данных PostgreSQL}%\footnote{Текст данных и последующих тезисов, кроме специально оговоренных случаев, доступен под лицензией Creative Commons Attribution"=ShareAlike 3.0}

\author{Юрий Бушмелев\footnote{Ульяновск, Россия; \url{jay4mail@gmail.com}}}
\maketitle

\begin{abstract}
Big PostgreSQL databases under heavy load require special care. Database administrator should keep eye on amount of\linebreak indexes and tables bloat and use special tools to reduce bloat level. Big databases need extra handling when doing backup as well. Replication management is another special task. This talk describe some solutions how to deal with such databases in production.
\end{abstract}

Когда базы PostgreSQL вырастают до сотен гигабайт, обеспечение их бесперебойной и быстрой работы под высокими нагрузками начинает требовать особых подходов.

Длительный срок эксплуатации при постоянной записи в БД порождает проблему «распухания» индексов и таблиц. Необходимо уметь оценивать степень «опухания», чтобы своевременно проводить обслуживание таблиц и индексов. Для оценки можно использовать запросы, приведенные в wiki\cite{Bush1} или в презентации Michael Glaesemann\cite{Bush2}.

«Распухшие» индексы можно пересоздать штатной конструкцией SQL REINDEX, но это заблокирует таблицу на запись на время пересоздания индекса. Более «либеральный» вариант "--- создать аналогичный индекс конструкцией CREATE INDEX\linebreak CONCURRENTLY, затем удалить старый индекс и переименовать новый.

Для «компактизации» таблиц можно использовать конструкции VACUUM FULL и CLUSTER, но они также блокируют обрабатываемые таблицы. Поэтому были созданы альтернативные инструменты: vacuum\_table.pl \cite{Bush3} /pgcompactor \cite{Bush4} и pg\_repack \cite{Bush5}.

Большой объем БД и постоянная нагрузка создают проблемы с резервным копированием. Здесь нужно соблюсти баланс между длительностью резервного копирования, создаваемой им нагрузкой на сервер БД и занимаемым им объемом. Самый простой способ "--- создать дамп базы с помощью pg\_dump, но он использует конструкцию COPY, которая блокирует таблицы, и создает нагрузку на сервер БД. Альтернативный вариант "--- копирование кластера БД с файловой системы и сохранение WAL-логов. Более интересный вариант "--- использование снапшотов ФС и сохранение WAL-логов. Также есть специализированные решения "--- pg\_rman \cite{Bush6} и WAL-E \cite{Bush7}.

Необходимость постоянной доступности БД требует включения репликации, что также определяет некоторые особенности в обращении с базами. 
Для создания потоковой реплики можно использовать как обычные средства сетевого копирования (scp и rsync), так и специализированные утилиты "--- pg\_basebackup и repmgr \cite{Bush8}.

Переключение ролей по описанному в руководстве способу (с использованием trigger\_file) приводит к необходимости пересоздания подчиненных реплик, что выливается в затраты времени и трафика. Если есть возможность последовательного перезапуска всех узлов кластера репликации, то можно просто переконфигурировать узлы в новую схему и перезапустить их с новыми ролями.

Каждое из решений обозначенных выше проблем имеет как свои плюсы, так и свои минусы. Выбор решений зависит от требований и возможностей каждой конкретной инфраструктуры.

\begin{thebibliography}{9}
\bibitem{Bush1}\url{http://wiki.postgresql.org/wiki/Show\_database\_bloat}
\bibitem{Bush2}\url{http://www.pgcon.org/2009/schedule/attachments/96\_visualizing-postgres-2009-05-21.pdf}
\bibitem{Bush3}\url{http://code.google.com/p/compacttable/}
\bibitem{Bush4}\url{http://code.google.com/p/pgtoolkit/}
\bibitem{Bush5}\url{https://github.com/reorg/pg\_repack}
\bibitem{Bush6}\url{http://code.google.com/p/pg-rman/}
\bibitem{Bush7}\url{https://github.com/heroku/WAL-E}
\bibitem{Bush8}\url{http://www.repmgr.org/}
\end{thebibliography}
\end{document}




